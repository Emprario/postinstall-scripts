#!/usr/bin/env python3

import os
import sys
import argparse
from functions import *


# parse arguments from the cli.
def process_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--append', action="store_true", dest="append", default=False,
                        help="Append a flag rather than replacing the whole command line")
    parser.add_argument('-r', '--reset', action="store_true", dest="reset", default=False,
                        help="Reset to default command line")
    parser.add_argument('-p', '--print-current', action="store_true", dest="print_current", default=False,
                        help="Show current command line")
    parser.add_argument("-v", "--verbose", action="store_true", dest="verbose", default=False, help="Print more output")
    # --set is more for ux than actual use
    parser.add_argument('-s', '--set', action="store_true",
                        help="Set new cmdline, must be followed by the new cmdline in quotes, example: \n" +
                             r'modify-cmdline -s "console=tty1 root=PARTUUID=7d83c214-289e-4e8b-93cc-685aea502 '
                             r'f59 i915.modeset=1 rootwait rw fbcon=logo-pos:center,logo-count:1 loglevel=0 splash"')
    parser.add_argument(dest='cmdline', type=str, nargs="?")
    return parser.parse_args()


if __name__ == "__main__":
    if os.geteuid() == 0 and not path_exists("/tmp/.root_ok"):
        print_error("Please start the script as non-root/without sudo")
        exit(1)

    args = process_args()
    if args.print_current:
        print_header("Current command line: ")
        with open("/proc/cmdline", "r") as file:
            print(file.read())
        exit(1)

    # Restart script as root
    if not os.geteuid() == 0:
        # install kernel packages before elevating to root, as makepkg needs to be run as non-root
        install_kernel_packages()
        # create empty file to confirm script was started as non-root
        with open("/tmp/.root_ok", "w") as file:
            file.write("")
        sudo_args = ['sudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('sudo', *sudo_args)

    # delete file to confirm script was started as root
    rmfile("/tmp/.root_ok")

    print_status("Reading partition table")
    partitions = bash("mount | grep ' / ' | cut -d' ' -f 1")
    partitions = partitions[:len(partitions) - 1]  # get device "name"
    if args.reset:
        print_status("Resetting to default command line")
        temp_cmdline = "console=tty1 root=PARTUUID=insert_partuuid i915.modeset=1 rootwait rw fbcon=logo-pos:center," \
                       "logo-count:1 quiet loglevel=3 vt.global_cursor_default=0 splash"
        rootfs_partuuid = bash(f"blkid -o value -s PARTUUID {partitions}2")  # get partuuid of rootfs
        new_cmdline = temp_cmdline.replace("insert_partuuid", rootfs_partuuid)  # replace PARTUUID in default cmdline
    else:
        if args.cmdline is None:
            print_error("No cmdline provided. Use --help for help")
            exit(1)
        new_cmdline = args.cmdline.strip()

    # Write the new kernel commandline to a file
    with open('cmdline', 'w') as file:
        if args.append:
            # Get the current kernel's command line
            with open("/proc/cmdline", "r") as file:
                current_cmdline = file.read().strip()
            file.write(f"{current_cmdline} {new_cmdline}")  # space needed as both args have no spaces before and after
        else:
            file.write(new_cmdline)

    # Copy old kernel partition
    kernel_partition = f"{partitions}1"
    bash(f"dd if={kernel_partition} of=old_kernel")
    print_status("Signing new kernel")
    bash("futility vbutil_kernel --repack new_kernel --version 1 --keyblock " +
         "/usr/share/vboot/devkeys/kernel.keyblock --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk " +
         "--oldblob old_kernel --config cmdline")
    print_status("Flashing new kernel")
    bash(f'sudo dd if=new_kernel of={kernel_partition}')
    print_status("New cmdline: ")
    if args.append:
        print_question(f"{current_cmdline} {new_cmdline}")  # green color
    else:
        print_question(f"{new_cmdline}")
    print_header("Reboot to apply changes")
